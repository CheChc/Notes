# 设计模式

# 第八章、设计优化

## 考点

**1、设计原则的理解**

 **接口隔离、依赖倒置、开放封闭、Liskov替换，单一职责、合成/聚合复用**

**2、设计模式**

**创建模式、结构模式、行为模式**

**抽象工厂、单例、适配器、门面、代理、观察者、状态、策略、合成**

## 设计原则

### 1、接口隔离

1、应该尽量使用“接口继承”，而非“实现继承”

2、通过接口，将需要的操作暴露给需要的类，将不需要的操作隐藏起来。接口充当类的视图。

### 2、依赖倒置

应依赖于抽象，而不是依赖于具体，这样做到最大程度的稳定。

### 3、开放封闭

一个模块对于拓展应该是开放的，而对于修改应该是封闭的。

有两个基本的特点：

- 模块的行为可以被拓展，以满足新的需求
- 模块的源代码不需要进行修改

### 4、Liskov替换原则

任何出现父类的地方，都应该能使子类进行无条件的替换。

### 5、单一职责原则

设计类的功能应该只有一个，而不应该为两个或者多个。

### 6、合成/聚合复用原则

尽量使用合成/聚合的委托重用，而不是使用继承的方式

继承会导致高耦合

## 设计模式

### 1、抽象工厂模式

- 简单工厂：生产一种产品。需要新增其他种类产品时需要修改工厂实例的代码（违背开闭原则）
- 工厂模式：不同的工厂生产不同的产品，一个工厂生产一种产品。需要新增其他种类产品时需要实例对应的工厂，产品过多的话工厂数量暴增，不增加复杂度，难以维护和理解。
- 抽象工厂：核心是生产一个集合的产品，生产出来的每个集合代表集合不同的态（例如上等品、中等品、次品）。如果新增不同等级的集合产品只需要再实现一个工厂类实例，则符合开闭原则，如果是需要在这个集合内加入新的产品，需要修改工厂类的接口，则不符合开闭原则。

### 2、单例模式

保证一个类仅有一个实例，并提供一个能访问他的全局节点

单例模式要求：

- 类的所有构造方法都是私有的，防止被外部创建
- 提供一个公有的方法获取该类的实例
- 类的实例变量为私有的或受保护的

### 3、适配器模式

把一个类的接口变换成该类期待的另一种接口，从而使原本因为接口不匹配的两个类可以一起工作

两种工作方式：委托和继承

### 4、桥模式

将抽象部分与实现部分分离，使他们都可以独立的变化。

本质上，主要解决两方面的变化：抽象与实现

将类之间静态的继承转换为动态的对象组合关系，使系统更加灵活，易于拓展